% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix-effects.R
\name{step_measure_standard_addition}
\alias{step_measure_standard_addition}
\title{Standard Addition Correction}
\usage{
step_measure_standard_addition(
  recipe,
  ...,
  addition_col = "addition",
  sample_id_col,
  min_points = 3,
  output_suffix = "_corrected",
  diagnostics = TRUE,
  role = "outcome",
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_standard_addition")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{...}{One or more selector functions to choose response columns
to correct using standard addition.}

\item{addition_col}{Name of the column containing the amount of standard
added (spike amount). Default is \code{"addition"}.}

\item{sample_id_col}{Name of the column identifying unique samples.
Each sample gets its own standard addition curve.}

\item{min_points}{Minimum number of addition points required per sample.
Default is 3.}

\item{output_suffix}{Suffix for output concentration columns.
Default is \code{"_corrected"}.}

\item{diagnostics}{Include diagnostic information (RÂ², slope, intercept)?
Default is TRUE.}

\item{role}{Recipe role for new columns. Default is \code{"outcome"}.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_standard_addition()} creates a \emph{specification} of a recipe step
that performs standard addition correction to compensate for matrix effects.
This method creates a sample-specific calibration for each unknown to
accurately quantify in the presence of matrix interference.
}
\details{
\subsection{Standard Addition Method}{

Standard addition works by:
\enumerate{
\item Splitting each unknown sample into multiple aliquots
\item Adding increasing known amounts of analyte to each aliquot
\item Measuring response for all aliquots
\item Extrapolating the regression line to x = -concentration
}

The original concentration is the absolute value of the x-intercept:
\code{concentration = -intercept / slope}
}

\subsection{Data Format}{

The input data should have:
\itemize{
\item A sample identifier column (each unique sample)
\item An addition amount column (0 for unspiked, then increasing amounts)
\item Response column(s) to be corrected
}
}

\subsection{When to Use}{

Use standard addition when:
\itemize{
\item Significant matrix effects are present
\item Matrix-matched calibrators are not available
\item Sample-to-sample matrix variation is expected
}
}

\subsection{Limitations}{
\itemize{
\item Requires multiple measurements per sample
\item Assumes linear response over the addition range
\item Does not correct for non-specific interferences
}
}
}
\examples{
library(recipes)

# Standard addition data for two samples
sa_data <- data.frame(
  sample_id = rep(c("Sample1", "Sample2"), each = 4),
  addition = rep(c(0, 10, 20, 30), 2),
  response = c(
    # Sample 1: original conc ~15
    150, 250, 350, 450,
    # Sample 2: original conc ~25
    250, 350, 450, 550
  )
)

rec <- recipe(~ ., data = sa_data) |>
  step_measure_standard_addition(
    response,
    addition_col = "addition",
    sample_id_col = "sample_id"
  ) |>
  prep()

bake(rec, new_data = NULL)
}
\seealso{
\code{\link[=measure_matrix_effect]{measure_matrix_effect()}}, \code{\link[=measure_calibration]{measure_calibration()}}

Other calibration: 
\code{\link{measure_matrix_effect}()},
\code{\link{step_measure_dilution_correct}()},
\code{\link{step_measure_surrogate_recovery}()}
}
\concept{calibration}
