% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak-operations.R
\name{step_measure_peaks_detect}
\alias{step_measure_peaks_detect}
\title{Detect Peaks in Measurements}
\usage{
step_measure_peaks_detect(
  recipe,
  algorithm = "prominence",
  min_height = 0,
  min_distance = 0,
  min_prominence = 0,
  snr_threshold = FALSE,
  algorithm_params = list(),
  measures = NULL,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_peaks_detect")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{algorithm}{Peak detection algorithm. One of \code{"prominence"} (default),
\code{"derivative"}, \code{"local_maxima"}, or any algorithm registered via

\code{\link[=register_peak_algorithm]{register_peak_algorithm()}}. Use \code{\link[=peak_algorithms]{peak_algorithms()}} to see available
algorithms.}

\item{min_height}{Minimum peak height. If \code{snr_threshold = TRUE}, this is
interpreted as a signal-to-noise ratio threshold.}

\item{min_distance}{Minimum distance between peaks in x-axis units.}

\item{min_prominence}{Minimum peak prominence (only for \code{algorithm = "prominence"}).}

\item{snr_threshold}{Logical. If \code{TRUE}, \code{min_height} is interpreted as a
signal-to-noise ratio. Noise is estimated as the MAD of the signal.}

\item{algorithm_params}{Named list of additional algorithm-specific parameters.
These are passed to the algorithm function along with the standard parameters.}

\item{measures}{Optional character vector of measure column names.}

\item{role}{Not used.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_peaks_detect()} creates a \emph{specification} of a recipe step that
detects peaks in measurement data and stores them in a new \code{.peaks} column.
}
\details{
This step detects peaks in measurement data and creates a new \code{.peaks}
column containing the detected peaks for each sample. The original
\code{.measures} column is preserved.

\strong{Detection algorithms:}
\itemize{
\item \code{"prominence"} (default): Finds local maxima and calculates their prominence
(how much a peak stands out from surrounding signal). More robust to noise.
\item \code{"derivative"}: Finds peaks by detecting zero-crossings in the first
derivative. Faster but more sensitive to noise.
\item \code{"local_maxima"}: Finds all local maxima above a threshold. Simple and fast
but may detect many spurious peaks.
}

Additional algorithms can be registered by technique packs using
\code{\link[=register_peak_algorithm]{register_peak_algorithm()}}.

\strong{Peak properties stored:}
\itemize{
\item \code{peak_id}: Integer identifier
\item \code{location}: X-axis position of peak apex
\item \code{height}: Y-value at peak apex
\item \code{left_base}, \code{right_base}: X-axis positions of peak boundaries
\item \code{area}: Initially NA; use \code{step_measure_peaks_integrate()} to calculate
}
}
\examples{
library(recipes)

rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_peaks_detect(min_height = 0.5, min_distance = 5) |>
  prep()

result <- bake(rec, new_data = NULL)
# Result now has .peaks column alongside .measures

# Use a different algorithm
rec2 <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_peaks_detect(algorithm = "derivative", min_height = 0.5) |>
  prep()
}
\seealso{
\code{\link[=peak_algorithms]{peak_algorithms()}}, \code{\link[=register_peak_algorithm]{register_peak_algorithm()}}

Other peak-operations: 
\code{\link{step_measure_peaks_filter}()},
\code{\link{step_measure_peaks_integrate}()},
\code{\link{step_measure_peaks_to_table}()}
}
\concept{peak-operations}
