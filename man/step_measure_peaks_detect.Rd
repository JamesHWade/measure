% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak-operations.R
\name{step_measure_peaks_detect}
\alias{step_measure_peaks_detect}
\title{Detect Peaks in Measurements}
\usage{
step_measure_peaks_detect(
  recipe,
  method = c("prominence", "derivative"),
  min_height = 0,
  min_distance = 0,
  min_prominence = 0,
  snr_threshold = FALSE,
  measures = NULL,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_peaks_detect")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{method}{Peak detection method. One of \code{"prominence"} (default) or
\code{"derivative"}.}

\item{min_height}{Minimum peak height. If \code{snr_threshold = TRUE}, this is
interpreted as a signal-to-noise ratio threshold.}

\item{min_distance}{Minimum distance between peaks in x-axis units.}

\item{min_prominence}{Minimum peak prominence (only for \code{method = "prominence"}).}

\item{snr_threshold}{Logical. If \code{TRUE}, \code{min_height} is interpreted as a
signal-to-noise ratio. Noise is estimated as the MAD of the signal.}

\item{measures}{Optional character vector of measure column names.}

\item{role}{Not used.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_peaks_detect()} creates a \emph{specification} of a recipe step that
detects peaks in measurement data and stores them in a new \code{.peaks} column.
}
\details{
This step detects peaks in measurement data and creates a new \code{.peaks}
column containing the detected peaks for each sample. The original
\code{.measures} column is preserved.

\strong{Detection methods:}
\itemize{
\item \code{"prominence"}: Finds local maxima and calculates their prominence (how
much a peak stands out from surrounding signal). More robust to noise.
\item \code{"derivative"}: Finds peaks by detecting zero-crossings in the first
derivative. Faster but more sensitive to noise.
}

\strong{Peak properties stored:}
\itemize{
\item \code{peak_id}: Integer identifier
\item \code{location}: X-axis position of peak apex
\item \code{height}: Y-value at peak apex
\item \code{left_base}, \code{right_base}: X-axis positions of peak boundaries
\item \code{area}: Initially NA; use \code{step_measure_peaks_integrate()} to calculate
}
}
\examples{
library(recipes)

rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_peaks_detect(min_height = 0.5, min_distance = 5) |>
  prep()

result <- bake(rec, new_data = NULL)
# Result now has .peaks column alongside .measures
}
\seealso{
Other peak-operations: 
\code{\link{step_measure_peaks_filter}()},
\code{\link{step_measure_peaks_integrate}()},
\code{\link{step_measure_peaks_to_table}()}
}
\concept{peak-operations}
