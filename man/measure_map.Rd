% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/measure-map.R
\name{measure_map}
\alias{measure_map}
\title{Apply a Function to Each Sample's Measurements}
\usage{
measure_map(.data, .f, .cols = NULL, ..., .error_call = rlang::caller_env())
}
\arguments{
\item{.data}{A data frame containing one or more \code{measure_list} columns.}

\item{.f}{A function or formula to apply to each sample's measurement tibble.
\itemize{
\item If a \strong{function}, it is used as-is.
\item If a \strong{formula} (e.g., \code{~ { .x$value <- log(.x$value); .x }}), it is
converted to a function using \code{\link[rlang:as_function]{rlang::as_function()}}.
}}

\item{.cols}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> Columns to apply
the transformation to. Defaults to all \code{measure_list} columns.}

\item{...}{Additional arguments passed to \code{.f}.}

\item{.error_call}{The execution environment for error reporting.}
}
\value{
A data frame with the specified measure columns transformed.
}
\description{
\code{measure_map()} applies a function to each sample's measurement data.
This function is intended for \strong{exploration and prototyping}, not for
production pipelines. For reproducible preprocessing, use
\code{\link[=step_measure_map]{step_measure_map()}} instead.
}
\details{
\subsection{Intended Use: Exploration, Not Production}{

This function is designed for interactive exploration and debugging:

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Good: Prototyping a new transformation
baked_data |>
  measure_map(~ \{ .x$value <- my_experimental_fn(.x$value); .x \})

# Better: Once it works, put it in a recipe step
recipe(...) |>
  step_measure_map(my_experimental_fn) |>
  prep()
}\if{html}{\out{</div>}}

Unlike recipe steps, transformations applied with \code{measure_map()} are NOT:
\itemize{
\item Automatically applied to new data
\item Bundled into workflows
\item Reproducible across sessions
}
}

\subsection{Function Requirements}{

The function \code{.f} must:
\itemize{
\item Accept a tibble with \code{location} and \code{value} columns
\item Return a tibble with \code{location} and \code{value} columns
\item Not change the number of rows
}
}
}
\examples{
library(recipes)

# First, get data in internal format
rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  prep()

baked_data <- bake(rec, new_data = NULL)

# Explore a custom transformation
result <- measure_map(baked_data, ~ {
  # Subtract the minimum value from each spectrum
  .x$value <- .x$value - min(.x$value)
  .x
})

# Once you're happy with it, use step_measure_map() in your recipe:
# recipe(...) |>
#   step_measure_map(~ { .x$value <- .x$value - min(.x$value); .x })
}
\seealso{
\itemize{
\item \code{\link[=step_measure_map]{step_measure_map()}} for production use in recipe pipelines
\item \code{\link[=measure_map_safely]{measure_map_safely()}} for fault-tolerant exploration
\item \code{\link[=measure_summarize]{measure_summarize()}} for computing summary statistics
}
}
