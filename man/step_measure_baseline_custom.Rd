% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/baseline-custom.R
\name{step_measure_baseline_custom}
\alias{step_measure_baseline_custom}
\title{Custom Baseline Correction with User-Provided Function}
\usage{
step_measure_baseline_custom(
  recipe,
  .fn,
  ...,
  subtract = TRUE,
  measures = NULL,
  tunable = NULL,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_baseline_custom")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{.fn}{A function or formula for baseline estimation. The function should
accept a \code{measure_tbl} (tibble with \code{location} and \code{value} columns) and
return a numeric vector of baseline values with the same length as the
input. Formulas are converted to functions via \code{\link[rlang:as_function]{rlang::as_function()}},
where \code{.x} represents the \code{measure_tbl}.}

\item{...}{Additional arguments passed to \code{.fn}. These are captured as
quosures and evaluated at bake time.}

\item{subtract}{If \code{TRUE} (default), the baseline is subtracted from the
signal. If \code{FALSE}, the baseline values replace the original values
(useful for extracting baselines).}

\item{measures}{An optional character vector of measure column names to
process. If \code{NULL} (the default), all measure columns (columns with class
\code{measure_list}) will be processed.}

\item{tunable}{An optional named list specifying which arguments in \code{...}
are tunable. Each element should be a list with \code{pkg}, \code{fun}, and
optionally \code{range}. See Details.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the quantities for preprocessing
have been estimated.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked?}

\item{id}{A character string that is unique to this step to identify it.}
}
\value{
An updated version of \code{recipe} with the new step added to the
sequence of any existing operations.
}
\description{
\code{step_measure_baseline_custom()} creates a \emph{specification} of a recipe step
that applies a user-provided function for baseline correction. This allows
for flexible, custom baseline estimation algorithms.
}
\details{
This step allows you to use any baseline estimation algorithm by providing
a custom function. The function receives a \code{measure_tbl} object (a tibble
with \code{location} and \code{value} columns) and should return a numeric vector
of the estimated baseline values.
\subsection{Function Contract}{

Your function should:
\itemize{
\item Accept a \code{measure_tbl} as its first argument
\item Return a numeric vector of the same length as \code{nrow(measure_tbl)}
\item Handle NA values appropriately
}
}

\subsection{Formula Interface}{

You can use a formula instead of a function. The formula is converted to a
function where \code{.x} represents the \code{measure_tbl}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# These are equivalent:
step_measure_baseline_custom(.fn = function(x) mean(x$value))
step_measure_baseline_custom(.fn = ~ mean(.x$value))
}\if{html}{\out{</div>}}
}

\subsection{Tunability}{

To make parameters tunable with \code{dials}, provide a \code{tunable} argument:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{step_measure_baseline_custom(
  .fn = ~ stats::loess(.x$value ~ .x$location, span = span)$fitted,
  span = 0.5,
  tunable = list(
    span = list(pkg = "dials", fun = "degree", range = c(0.1, 0.9))
  )
)
}\if{html}{\out{</div>}}

\strong{No selectors should be supplied to this step function}. The data should be
in the internal format produced by \code{\link[=step_measure_input_wide]{step_measure_input_wide()}} or
\code{\link[=step_measure_input_long]{step_measure_input_long()}}.
}
}
\section{Tidying}{
When you \code{\link[recipes:tidy.recipe]{tidy()}} this step, a tibble with columns
\code{terms}, \code{subtract}, and \code{id} is returned.
}

\examples{
library(recipes)

# Simple polynomial baseline using a function
poly_baseline <- function(x) {
  fit <- lm(x$value ~ poly(x$location, 2))
  predict(fit)
}

rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_baseline_custom(.fn = poly_baseline) |>
  prep()

bake(rec, new_data = NULL)

# Using formula interface with additional parameters
rec2 <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_baseline_custom(
    .fn = ~ stats::loess(.x$value ~ .x$location, span = span)$fitted,
    span = 0.5
  ) |>
  prep()
}
\seealso{
\code{\link[=step_measure_baseline_als]{step_measure_baseline_als()}}, \code{\link[=step_measure_baseline_poly]{step_measure_baseline_poly()}} for
built-in baseline correction methods.

Other measure-baseline: 
\code{\link{step_measure_baseline_airpls}()},
\code{\link{step_measure_baseline_als}()},
\code{\link{step_measure_baseline_arpls}()},
\code{\link{step_measure_baseline_auto}()},
\code{\link{step_measure_baseline_gpc}()},
\code{\link{step_measure_baseline_minima}()},
\code{\link{step_measure_baseline_morph}()},
\code{\link{step_measure_baseline_poly}()},
\code{\link{step_measure_baseline_py}()},
\code{\link{step_measure_baseline_rf}()},
\code{\link{step_measure_baseline_rolling}()},
\code{\link{step_measure_baseline_snip}()},
\code{\link{step_measure_baseline_tophat}()},
\code{\link{step_measure_detrend}()}
}
\concept{measure-baseline}
