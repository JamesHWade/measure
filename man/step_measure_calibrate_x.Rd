% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibrate.R
\name{step_measure_calibrate_x}
\alias{step_measure_calibrate_x}
\title{Apply X-Axis Calibration}
\usage{
step_measure_calibrate_x(
  recipe,
  calibration,
  from = "x",
  to = "y",
  method = "spline",
  extrapolate = FALSE,
  measures = NULL,
  role = NA,
  trained = FALSE,
  cal_fn = NULL,
  skip = FALSE,
  id = recipes::rand_id("measure_calibrate_x")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{calibration}{The calibration to apply. Can be:
\itemize{
\item A data.frame with columns specified by \code{from} and \code{to}
\item A function that takes location values and returns calibrated values
}}

\item{from}{Column name in calibration data.frame containing original
x values. Default is \code{"x"}.}

\item{to}{Column name in calibration data.frame containing calibrated
values. Default is \code{"y"}.}

\item{method}{Interpolation method when using calibration data.frame:
\itemize{
\item \code{"linear"}: Linear interpolation
\item \code{"spline"} (default): Cubic spline interpolation
}}

\item{extrapolate}{Logical. If \code{TRUE}, allow extrapolation outside the
calibration range. If \code{FALSE} (default), values outside the range will
return \code{NA} for linear interpolation or use spline extrapolation.}

\item{measures}{An optional character vector of measure column names to
process. If \code{NULL} (the default), all measure columns will be processed.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the step has been trained.}

\item{cal_fn}{The calibration function created during training.}

\item{skip}{A logical. Should the step be skipped when baking?}

\item{id}{A character string that is unique to this step.}
}
\value{
An updated version of \code{recipe} with the new step added.
}
\description{
\code{step_measure_calibrate_x()} creates a \emph{specification} of a recipe step
that transforms the x-axis (location) values using a calibration function
or calibration data.
}
\details{
X-axis calibration is commonly used to convert raw measurement units to
physically meaningful values. Common examples include:
\itemize{
\item \strong{GPC/SEC}: Convert retention time to molecular weight (via log MW)
\item \strong{Mass spectrometry}: Apply m/z calibration corrections
\item \strong{Spectroscopy}: Convert pixel or channel numbers to wavelength/wavenumber
}

The calibration can be provided as either:
\enumerate{
\item \strong{Calibration data}: A data.frame with known xâ†’y mappings. The step
will build an interpolation function during \code{prep()}.
\item \strong{Calibration function}: A function that directly transforms x values.
}

\strong{Warning}: This step modifies the \code{location} column. Subsequent steps
will see the calibrated values. Make sure your calibration is appropriate
for your data range.

\strong{No selectors should be supplied to this step function}. The data should be
in the internal format produced by \code{\link[=step_measure_input_wide]{step_measure_input_wide()}} or
\code{\link[=step_measure_input_long]{step_measure_input_long()}}.
}
\section{Tidying}{
When you \code{\link[recipes:tidy.recipe]{tidy()}} this step, a tibble with columns
\code{terms}, \code{method}, \code{extrapolate}, and \code{id} is returned.
}

\examples{
library(recipes)

# Example: GPC molecular weight calibration
# Calibration standards: retention_time -> log(MW)
gpc_cal <- data.frame(
  retention_time = c(10, 12, 14, 16, 18),
  log_mw = c(6.5, 5.8, 5.0, 4.2, 3.5)
)

# Note: meats_long doesn't have retention time, this is illustrative
rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_calibrate_x(
    calibration = function(x) log10(x + 1),  # Example transformation
    method = "spline"
  )

# With calibration data
# rec <- recipe(...) |>
#   step_measure_calibrate_x(
#     calibration = gpc_cal,
#     from = "retention_time",
#     to = "log_mw",
#     method = "spline"
#   )
}
\seealso{
\code{\link[=step_measure_calibrate_y]{step_measure_calibrate_y()}} for y-axis calibration

Other measure-preprocessing: 
\code{\link{step_measure_calibrate_y}()},
\code{\link{step_measure_map}()},
\code{\link{step_measure_msc}()},
\code{\link{step_measure_normalize_istd}()},
\code{\link{step_measure_ratio_reference}()},
\code{\link{step_measure_snv}()},
\code{\link{step_measure_subtract_blank}()},
\code{\link{step_measure_subtract_reference}()}
}
\concept{measure-preprocessing}
