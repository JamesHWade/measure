% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak-operations.R
\name{step_measure_peaks_deconvolve}
\alias{step_measure_peaks_deconvolve}
\title{Deconvolve Overlapping Peaks}
\usage{
step_measure_peaks_deconvolve(
  recipe,
  model = c("gaussian", "emg", "bigaussian"),
  max_iter = 100L,
  tol = 1e-06,
  peaks_col = ".peaks",
  measures_col = ".measures",
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_peaks_deconvolve")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{model}{Peak model to use: "gaussian" (symmetric), "emg" (exponentially
modified Gaussian for tailing peaks), or "bigaussian" (asymmetric).
Default is "gaussian".}

\item{max_iter}{Maximum iterations for optimization. Default is 100.}

\item{tol}{Convergence tolerance. Default is 1e-6.}

\item{peaks_col}{Name of the peaks column. Default is ".peaks".}

\item{measures_col}{Name of the measures column. Default is ".measures".}

\item{role}{Not used.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added. The \code{.peaks} column
will be updated with deconvolved peak parameters and fitted areas.
}
\description{
\code{step_measure_peaks_deconvolve()} creates a \emph{specification} of a recipe step
that resolves overlapping peaks using curve fitting. This step requires
peaks to have been detected first using \code{\link[=step_measure_peaks_detect]{step_measure_peaks_detect()}}.
}
\details{
Peak deconvolution fits mathematical models to overlapping peaks to
determine their individual contributions. This is essential for
quantitative analysis when peaks are not baseline-resolved.

\strong{Peak Models:}
\itemize{
\item \code{gaussian}: Symmetric Gaussian peak (3 params: height, center, width)
\item \code{emg}: Exponentially Modified Gaussian (4 params, handles tailing)
\item \code{bigaussian}: Bi-Gaussian (5 params, flexible asymmetry)
}

The optimization uses initial estimates from detected peak positions
and refines them to minimize the residual sum of squares.
}
\examples{
library(recipes)

# Deconvolve overlapping peaks
# rec <- recipe(~., data = chromatogram_data) |>
#   step_measure_input_long(signal, location = vars(time)) |>
#   step_measure_peaks_detect(method = "derivative") |>
#   step_measure_peaks_deconvolve(model = "gaussian") |>
#   prep()
}
\seealso{
Other measure-chromatography: 
\code{\link{step_measure_mw_averages}()},
\code{\link{step_measure_mw_distribution}()},
\code{\link{step_measure_mw_fractions}()}
}
\concept{measure-chromatography}
