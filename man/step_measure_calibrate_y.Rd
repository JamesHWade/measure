% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibrate.R
\name{step_measure_calibrate_y}
\alias{step_measure_calibrate_y}
\title{Apply Y-Axis Calibration (Response Factor)}
\usage{
step_measure_calibrate_y(
  recipe,
  response_factor = 1,
  calibration = NULL,
  measures = NULL,
  role = NA,
  trained = FALSE,
  cal_fn = NULL,
  skip = FALSE,
  id = recipes::rand_id("measure_calibrate_y")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{response_factor}{A numeric value to multiply all values by.
Default is \code{1.0} (no change). This is a simple scalar calibration.}

\item{calibration}{An optional calibration function that takes value(s)
and returns calibrated value(s). If provided, this takes precedence
over \code{response_factor}.}

\item{measures}{An optional character vector of measure column names to
process. If \code{NULL} (the default), all measure columns will be processed.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the step has been trained.}

\item{cal_fn}{The calibration function to apply (built during prep).}

\item{skip}{A logical. Should the step be skipped when baking?}

\item{id}{A character string that is unique to this step.}
}
\value{
An updated version of \code{recipe} with the new step added.
}
\description{
\code{step_measure_calibrate_y()} creates a \emph{specification} of a recipe step
that applies a response factor or calibration function to y-axis (value)
values.
}
\details{
Y-axis calibration is used to convert raw signal intensities to
quantitative values. Common examples include:
\itemize{
\item \strong{Chromatography}: Apply detector response factors
\item \strong{Spectroscopy}: Apply molar absorptivity corrections
\item \strong{Mass spectrometry}: Apply ionization efficiency corrections
}

\strong{Simple mode}: Use \code{response_factor} to multiply all values by a constant.

\strong{Complex mode}: Use \code{calibration} to provide a function for non-linear
calibration curves (e.g., from fitting standards).

\strong{No selectors should be supplied to this step function}. The data should be
in the internal format produced by \code{\link[=step_measure_input_wide]{step_measure_input_wide()}} or
\code{\link[=step_measure_input_long]{step_measure_input_long()}}.
}
\section{Tidying}{
When you \code{\link[recipes:tidy.recipe]{tidy()}} this step, a tibble with columns
\code{terms}, \code{response_factor}, \code{has_calibration}, and \code{id} is returned.
}

\examples{
library(recipes)

# Simple response factor
rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_calibrate_y(response_factor = 2.5)

# With calibration function (e.g., log transform)
rec2 <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_calibrate_y(calibration = function(x) log10(x + 0.001))
}
\seealso{
\code{\link[=step_measure_calibrate_x]{step_measure_calibrate_x()}} for x-axis calibration

Other measure-preprocessing: 
\code{\link{step_measure_absorbance}()},
\code{\link{step_measure_calibrate_x}()},
\code{\link{step_measure_derivative}()},
\code{\link{step_measure_derivative_gap}()},
\code{\link{step_measure_emsc}()},
\code{\link{step_measure_kubelka_munk}()},
\code{\link{step_measure_log}()},
\code{\link{step_measure_map}()},
\code{\link{step_measure_msc}()},
\code{\link{step_measure_normalize_istd}()},
\code{\link{step_measure_osc}()},
\code{\link{step_measure_ratio_reference}()},
\code{\link{step_measure_snv}()},
\code{\link{step_measure_subtract_blank}()},
\code{\link{step_measure_subtract_reference}()},
\code{\link{step_measure_transmittance}()}
}
\concept{measure-preprocessing}
