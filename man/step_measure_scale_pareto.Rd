% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale-variable.R
\name{step_measure_scale_pareto}
\alias{step_measure_scale_pareto}
\title{Pareto Scaling}
\usage{
step_measure_scale_pareto(
  recipe,
  measures = NULL,
  role = NA,
  trained = FALSE,
  learned_params = NULL,
  skip = FALSE,
  id = recipes::rand_id("measure_scale_pareto")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{measures}{An optional character vector of measure column names to
process. If \code{NULL} (the default), all measure columns (columns with class
\code{measure_list}) will be processed. Use this to limit processing to specific
measure columns when working with multiple measurement types.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the quantities for preprocessing
have been estimated.}

\item{learned_params}{A named list containing learned means and locations
for each measure column. This is \code{NULL} until the step is trained.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked
by \code{\link[recipes:bake]{recipes::bake()}}? While all operations are baked when \code{\link[recipes:prep]{recipes::prep()}} is run, some
operations may not be able to be conducted on new data (e.g. processing
the outcome variable(s)). Care should be taken when using \code{skip = TRUE}
as it may affect the computations for subsequent operations.}

\item{id}{A character string that is unique to this step to identify it.}
}
\value{
An updated version of \code{recipe} with the new step added to the
sequence of any existing operations.
}
\description{
\code{step_measure_scale_pareto()} creates a \emph{specification} of a recipe step that
applies Pareto scaling at each measurement location. This is a compromise
between no scaling and auto-scaling, commonly used in metabolomics.
}
\details{
Pareto scaling divides by the square root of the standard deviation rather
than the standard deviation itself. This reduces the relative importance of
large values while still giving more weight to larger fold changes.

For a data matrix \eqn{X}, the transformation is:

\deqn{X_{scaled} = \frac{X - \bar{X}}{\sqrt{s_X}}}{X_scaled = (X - mean(X)) / sqrt(sd(X))}

where \eqn{\bar{X}}{mean(X)} and \eqn{s_X}{sd(X)} are the column-wise mean
and standard deviation computed from the training data.

If a column has zero standard deviation (constant values), that column is
only centered, not scaled.

The means and standard deviations are learned during \code{prep()} from the
training data and stored for use when applying the transformation to new
data during \code{bake()}.

\strong{No selectors should be supplied to this step function}. The data should be
in the internal format produced by \code{\link[=step_measure_input_wide]{step_measure_input_wide()}} or
\code{\link[=step_measure_input_long]{step_measure_input_long()}}.
}
\examples{
library(recipes)

rec <-
  recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_scale_pareto() |>
  prep()

bake(rec, new_data = NULL)
}
\references{
van den Berg, R.A., Hoefsloot, H.C., Westerhuis, J.A., Smilde, A.K., and
van der Werf, M.J. 2006. Centering, scaling, and transformations: improving
the biological information content of metabolomics data. BMC Genomics, 7:142.
}
\seealso{
\code{\link[=step_measure_scale_auto]{step_measure_scale_auto()}}, \code{\link[=step_measure_center]{step_measure_center()}}

Other measure-scaling: 
\code{\link{step_measure_center}()},
\code{\link{step_measure_scale_auto}()},
\code{\link{step_measure_scale_range}()},
\code{\link{step_measure_scale_vast}()}
}
\concept{measure-scaling}
