% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/measure-map.R
\name{step_measure_map}
\alias{step_measure_map}
\title{Apply a Custom Function to Measurements}
\usage{
step_measure_map(
  recipe,
  fn,
  ...,
  measures = NULL,
  verbosity = 1L,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_map")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{fn}{A function to apply to each sample's measurement tibble. The

function should accept a tibble with \code{location} and \code{value} columns and
return a tibble with the same structure. Can also be a formula (e.g.,
\code{~ { .x$value <- log1p(.x$value); .x }}) which will be converted via
\code{\link[rlang:as_function]{rlang::as_function()}}.}

\item{...}{Additional arguments passed to \code{fn} during baking.}

\item{measures}{An optional character vector of measure column names to

process. If \code{NULL} (the default), all measure columns will be processed.}

\item{verbosity}{An integer controlling output verbosity:
\itemize{
\item \code{0}: Silent - suppress all messages and output from \code{fn}
\item \code{1}: Normal (default) - show output from \code{fn}
}}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the step has been trained.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked?}

\item{id}{A character string that is unique to this step.}
}
\value{
An updated version of \code{recipe} with the new step added.
}
\description{
\code{step_measure_map()} creates a \emph{specification} of a recipe step that applies
a custom function to each sample's measurements. Use this when the built-in
preprocessing steps (SNV, MSC, Savitzky-Golay) don't cover your needs.
}
\details{
This step is the "escape hatch" for custom sample-wise transformations that
aren't covered by the built-in steps. It integrates fully with the recipes
framework, meaning your custom transformation will be:
\itemize{
\item Applied consistently during \code{prep()} and \code{bake()}
\item Included when bundling recipes into workflows
\item Reproducible across sessions
}
\subsection{Function Requirements}{

The function \code{fn} must:
\itemize{
\item Accept a tibble with \code{location} and \code{value} columns
\item Return a tibble with \code{location} and \code{value} columns
\item Not change the number of rows (measurements must remain aligned)
}
}

\subsection{When to Use This Step}{

Use \code{step_measure_map()} for domain-specific transformations not covered
by the built-in steps:
\itemize{
\item Custom baseline correction algorithms
\item Specialized normalization methods
\item Instrument-specific corrections
\item Experimental preprocessing techniques
}

For common operations, prefer the built-in steps:
\itemize{
\item Scatter correction → \code{\link[=step_measure_snv]{step_measure_snv()}} or \code{\link[=step_measure_msc]{step_measure_msc()}}
\item Smoothing/derivatives → \code{\link[=step_measure_savitzky_golay]{step_measure_savitzky_golay()}}
}
}

\subsection{Prototyping with measure_map()}{

When developing a custom transformation, you may find it helpful to
prototype using \code{\link[=measure_map]{measure_map()}} on baked data before wrapping it in
a step. Once your function works correctly, use `step_measure_

for production pipelines.
}
}
\examples{
library(recipes)

# Example 1: Custom log transformation
log_transform <- function(x) {
  x$value <- log1p(x$value)
  x
}

rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_map(log_transform) |>
  step_measure_snv() |>
  prep()

bake(rec, new_data = NULL)

# Example 2: Using formula syntax for inline transformations
rec2 <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_map(~ {
    # Subtract minimum to remove offset
    .x$value <- .x$value - min(.x$value)
    .x
  }) |>
  prep()

# Example 3: Using external package functions
# (e.g., custom baseline from a spectroscopy package)
\dontrun{
rec3 <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_map(my_baseline_correction, method = "als") |>
  step_measure_output_wide()
}
}
\seealso{
\itemize{
\item \code{\link[=step_measure_snv]{step_measure_snv()}}, \code{\link[=step_measure_msc]{step_measure_msc()}}, \code{\link[=step_measure_savitzky_golay]{step_measure_savitzky_golay()}}
for built-in preprocessing steps
\item \code{\link[=measure_map]{measure_map()}} for prototyping custom transformations
}

Other measure-preprocessing: 
\code{\link{step_measure_absorbance}()},
\code{\link{step_measure_calibrate_x}()},
\code{\link{step_measure_calibrate_y}()},
\code{\link{step_measure_derivative}()},
\code{\link{step_measure_derivative_gap}()},
\code{\link{step_measure_kubelka_munk}()},
\code{\link{step_measure_log}()},
\code{\link{step_measure_msc}()},
\code{\link{step_measure_normalize_istd}()},
\code{\link{step_measure_ratio_reference}()},
\code{\link{step_measure_snv}()},
\code{\link{step_measure_subtract_blank}()},
\code{\link{step_measure_subtract_reference}()},
\code{\link{step_measure_transmittance}()}
}
\concept{measure-preprocessing}
