% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/drift-correction.R
\name{step_measure_drift_qc_loess}
\alias{step_measure_drift_qc_loess}
\title{QC-Based Drift Correction Using LOESS}
\usage{
step_measure_drift_qc_loess(
  recipe,
  ...,
  run_order_col = "run_order",
  sample_type_col = "sample_type",
  qc_type = "qc",
  apply_to = c("all", "unknown"),
  span = 0.75,
  degree = 2,
  robust = TRUE,
  min_qc = 5,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_drift_qc_loess")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{...}{One or more selector functions to choose feature columns. For
feature-level data, select the numeric response columns. For curve-level
data with \code{.measures}, leave empty to apply to all locations.}

\item{run_order_col}{Name of the column containing run order (injection
sequence). Must be numeric/integer.}

\item{sample_type_col}{Name of the column containing sample type.}

\item{qc_type}{Value(s) in \code{sample_type_col} that identify QC samples to
use for drift modeling. Default is \code{"qc"}.}

\item{apply_to}{Which samples to apply correction to:
\itemize{
\item \code{"all"} (default): Correct all samples
\item \code{"unknown"}: Only correct unknown samples
}}

\item{span}{LOESS span parameter controlling smoothness. Default is 0.75.
Smaller values = more flexible fit.}

\item{degree}{Polynomial degree for LOESS (1 or 2). Default is 2.}

\item{robust}{Logical. Use robust LOESS fitting? Default is TRUE.}

\item{min_qc}{Minimum number of QC samples required. Default is 5.}

\item{role}{Not used by this step.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_drift_qc_loess()} creates a \emph{specification} of a recipe step
that corrects for signal drift across run order using QC (or reference)
samples. This implements the QC-RLSC (robust LOESS signal correction) method.
}
\details{
\subsection{How It Works}{
\enumerate{
\item During \code{prep()}: A LOESS model is fit to QC sample responses vs run order
for each feature/location.
\item During \code{bake()}: Correction factors are calculated as:
\code{correction = median(QC_responses) / predicted_value}

Each sample's response is multiplied by the correction factor at its
run order position.
}
}

\subsection{Data Levels}{

This step supports both:
\itemize{
\item \strong{Feature-level data}: Applies correction to each selected numeric column
\item \strong{Curve-level data}: Applies correction to each location in the measure_list
}
}

\subsection{Diagnostics}{

The trained step stores drift model information accessible via \code{tidy()}:
\itemize{
\item LOESS model parameters
\item QC response trends
\item Correction factors applied
}
}
}
\examples{
library(recipes)

# Feature-level data with drift
data <- data.frame(
  sample_id = paste0("S", 1:20),
  sample_type = rep(c("qc", "unknown", "unknown", "unknown", "qc"), 4),
  run_order = 1:20,
  feature1 = 100 + (1:20) * 0.5 + rnorm(20, sd = 2),  # Upward drift
  feature2 = 50 - (1:20) * 0.3 + rnorm(20, sd = 1)    # Downward drift
)

rec <- recipe(~ ., data = data) |>
  update_role(sample_id, new_role = "id") |>
  step_measure_drift_qc_loess(feature1, feature2) |>
  prep()

corrected <- bake(rec, new_data = NULL)
}
\seealso{
\code{\link[=measure_detect_drift]{measure_detect_drift()}} for drift detection before correction.

Other drift-correction: 
\code{\link{step_measure_drift_linear}()},
\code{\link{step_measure_drift_spline}()},
\code{\link{step_measure_qc_bracket}()}
}
\concept{drift-correction}
