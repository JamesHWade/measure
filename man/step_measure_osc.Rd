% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scatter-extended.R
\name{step_measure_osc}
\alias{step_measure_osc}
\title{Orthogonal Signal Correction (OSC)}
\usage{
step_measure_osc(
  recipe,
  n_components = 1L,
  tolerance = 1e-06,
  max_iter = 100L,
  measures = NULL,
  role = NA,
  trained = FALSE,
  weights = NULL,
  loadings = NULL,
  skip = FALSE,
  id = recipes::rand_id("measure_osc")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{n_components}{Number of orthogonal components to remove. Default is 1.}

\item{tolerance}{Convergence tolerance for NIPALS algorithm. Default is 1e-6.}

\item{max_iter}{Maximum iterations for NIPALS. Default is 100.}

\item{measures}{An optional character vector of measure column names.}

\item{role}{Not used.}

\item{trained}{Logical indicating if the step has been trained.}

\item{weights}{The learned orthogonal weights (after training).}

\item{loadings}{The learned orthogonal loadings (after training).}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_osc()} creates a \emph{specification} of a recipe step that applies
Orthogonal Signal Correction to remove variation orthogonal to the outcome.
}
\details{
Orthogonal Signal Correction (OSC) removes variation in X that is orthogonal
to Y (the outcome). This is useful for removing systematic variation that
is not related to the response.

\strong{Algorithm:}
\enumerate{
\item Compute initial score t from Y using SVD
\item Orthogonalize t with respect to Y
\item Iterate NIPALS to find orthogonal components
\item Remove orthogonal components from X
}

\strong{Important:}
\itemize{
\item The recipe must have at least one outcome variable with role "outcome"
\item Outcomes are automatically detected from the recipe's role definitions
\item Multiple outcomes are supported (multivariate Y)
}

OSC was originally described by Wold et al. (1998) for NIR spectroscopy.
}
\examples{
library(recipes)

rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_osc(n_components = 2) |>
  prep()

bake(rec, new_data = NULL)
}
\references{
Wold, S., Antti, H., Lindgren, F., and Ohman, J. (1998). Orthogonal signal
correction of near-infrared spectra. Chemometrics and Intelligent Laboratory
Systems, 44(1-2), 175-185.
}
\seealso{
Other measure-preprocessing: 
\code{\link{step_measure_absorbance}()},
\code{\link{step_measure_calibrate_x}()},
\code{\link{step_measure_calibrate_y}()},
\code{\link{step_measure_derivative}()},
\code{\link{step_measure_derivative_gap}()},
\code{\link{step_measure_emsc}()},
\code{\link{step_measure_kubelka_munk}()},
\code{\link{step_measure_log}()},
\code{\link{step_measure_map}()},
\code{\link{step_measure_msc}()},
\code{\link{step_measure_normalize_istd}()},
\code{\link{step_measure_ratio_reference}()},
\code{\link{step_measure_snv}()},
\code{\link{step_measure_subtract_blank}()},
\code{\link{step_measure_subtract_reference}()},
\code{\link{step_measure_transmittance}()}
}
\concept{measure-preprocessing}
