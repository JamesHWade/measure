% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smooth-wavelet.R
\name{step_measure_smooth_wavelet}
\alias{step_measure_smooth_wavelet}
\title{Wavelet Denoising}
\usage{
step_measure_smooth_wavelet(
  recipe,
  measures = NULL,
  wavelet = "DaubExPhase",
  filter_number = 4L,
  threshold_type = c("soft", "hard"),
  threshold_policy = c("universal", "sure", "cv"),
  levels = NULL,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_smooth_wavelet")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{measures}{An optional character vector of measure column names.}

\item{wavelet}{The wavelet family to use. Default is \code{"DaubExPhase"}.
Options include \code{"DaubExPhase"}, \code{"DaubLeAsworthy"}, \code{"Lawton"}.}

\item{filter_number}{The filter number within the wavelet family. Default
is 4. Higher numbers give smoother wavelets.}

\item{threshold_type}{Type of thresholding: \code{"soft"} (default) or \code{"hard"}.
Soft thresholding shrinks coefficients toward zero; hard thresholding
sets small coefficients exactly to zero.}

\item{threshold_policy}{How to determine the threshold:
\itemize{
\item \code{"universal"} (default): Uses universal threshold sqrt(2*log(n))
\item \code{"sure"}: Stein's Unbiased Risk Estimate
\item \code{"cv"}: Cross-validation
}}

\item{levels}{Number of decomposition levels. Default is \code{NULL} (auto).}

\item{role}{Not used.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_smooth_wavelet()} creates a \emph{specification} of a recipe step
that applies wavelet-based denoising to measurement data. This method is
particularly effective for signals with localized features like peaks.
}
\details{
Wavelet denoising works by:
\enumerate{
\item Decomposing the signal into wavelet coefficients
\item Thresholding small coefficients (presumed to be noise)
\item Reconstructing the signal from remaining coefficients
}

This approach is powerful because:
\itemize{
\item It adapts to local signal characteristics
\item It preserves sharp features like peaks
\item It can separate noise from signal at multiple scales
}

Requires the \code{wavethresh} package to be installed.
}
\note{
Wavelet transforms require signal lengths that are powers of 2. Signals
are automatically padded to the next power of 2 and trimmed after
processing.
}
\examples{
library(recipes)

rec <- recipe(water + fat + protein ~ ., data = meats_long) |>
  update_role(id, new_role = "id") |>
  step_measure_input_long(transmittance, location = vars(channel)) |>
  step_measure_smooth_wavelet() |>
  prep()

bake(rec, new_data = NULL)
}
\seealso{
Other measure-smoothing: 
\code{\link{step_measure_despike}()},
\code{\link{step_measure_filter_fourier}()},
\code{\link{step_measure_savitzky_golay}()},
\code{\link{step_measure_smooth_gaussian}()},
\code{\link{step_measure_smooth_ma}()},
\code{\link{step_measure_smooth_median}()}
}
\concept{measure-smoothing}
