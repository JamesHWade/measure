% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/drift-correction.R
\name{step_measure_qc_bracket}
\alias{step_measure_qc_bracket}
\title{QC Bracketing Interpolation}
\usage{
step_measure_qc_bracket(
  recipe,
  ...,
  run_order_col = "run_order",
  sample_type_col = "sample_type",
  qc_type = "qc",
  apply_to = c("all", "unknown"),
  extrapolate = TRUE,
  min_qc = 2,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = recipes::rand_id("measure_qc_bracket")
)
}
\arguments{
\item{recipe}{A recipe object.}

\item{...}{One or more selector functions to choose feature columns. For
feature-level data, select the numeric response columns. For curve-level
data with \code{.measures}, leave empty to apply to all locations.}

\item{run_order_col}{Name of the column containing run order (injection
sequence). Must be numeric/integer.}

\item{sample_type_col}{Name of the column containing sample type.}

\item{qc_type}{Value(s) in \code{sample_type_col} that identify QC samples to
use for drift modeling. Default is \code{"qc"}.}

\item{apply_to}{Which samples to apply correction to:
\itemize{
\item \code{"all"} (default): Correct all samples
\item \code{"unknown"}: Only correct unknown samples
}}

\item{extrapolate}{Logical. Should correction be extrapolated for samples
before the first or after the last QC? Default is TRUE. If FALSE, those
samples use the nearest QC's correction factor.}

\item{min_qc}{Minimum number of QC samples required. Default is 5.}

\item{role}{Not used by this step.}

\item{trained}{Logical indicating if the step has been trained.}

\item{skip}{Logical. Should the step be skipped when baking?}

\item{id}{Unique step identifier.}
}
\value{
An updated recipe with the new step added.
}
\description{
\code{step_measure_qc_bracket()} creates a \emph{specification} of a recipe step
that corrects for drift using linear interpolation between bracketing
QC or reference samples. This is a simple, intuitive method where each
sample is corrected based on the two nearest QC samples.
}
\details{
\subsection{How It Works}{

For each sample at run order \code{t}:
\enumerate{
\item Find the nearest QC samples before (\code{t1}) and after (\code{t2})
\item Calculate correction factors at \code{t1} and \code{t2} (target / observed)
\item Linearly interpolate the correction factor for \code{t}
\item Apply the interpolated correction
}

This method is commonly used in clinical and bioanalytical laboratories
where QC samples are injected at regular intervals throughout the run.
}

\subsection{When to Use}{
\itemize{
\item Regular QC injection intervals
\item Short analytical runs
\item When you want simple, transparent corrections
\item Regulatory environments where interpretability is important
}
}
}
\examples{
library(recipes)

# Data with QC samples at regular intervals
data <- data.frame(
  sample_id = paste0("S", 1:15),
  sample_type = c("qc", rep("unknown", 4), "qc", rep("unknown", 4), "qc",
                  rep("unknown", 3), "qc"),
  run_order = 1:15,
  feature1 = c(100, 101, 103, 105, 107, 105, 107, 109, 111, 113,
               110, 112, 114, 116, 115)  # Drift pattern
)

rec <- recipe(~ ., data = data) |>
  update_role(sample_id, new_role = "id") |>
  step_measure_qc_bracket(feature1) |>
  prep()

corrected <- bake(rec, new_data = NULL)
}
\seealso{
Other drift-correction: 
\code{\link{step_measure_drift_linear}()},
\code{\link{step_measure_drift_qc_loess}()},
\code{\link{step_measure_drift_spline}()}
}
\concept{drift-correction}
