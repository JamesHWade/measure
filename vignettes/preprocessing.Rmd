---
title: "Preprocessing Techniques"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preprocessing Techniques}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4,
  warning = FALSE
)
```

```{r setup, message = FALSE}
library(measure)
library(recipes)
library(dplyr)
library(tidyr)
library(ggplot2)
library(modeldata)

# Helper function to process and plot spectra
plot_spectra <- function(data, title, subtitle = NULL) {
  ggplot(data, aes(x = location, y = value, group = sample_id, color = factor(sample_id))) +
    geom_line(alpha = 0.7, linewidth = 0.5) +
    labs(x = "Wavelength", y = "Signal", title = title, subtitle = subtitle) +
    theme_minimal() +
    theme(legend.position = "none")
}

# Prepare sample data
data(meats)
wavelengths <- seq(850, 1050, length.out = 100)

# Get spectra in internal format for demonstrations
get_internal <- function(rec) {
  bake(prep(rec), new_data = NULL) |>
    slice(1:15) |>
    mutate(sample_id = row_number()) |>
    unnest(.measures)
}
```

## Introduction

Spectral preprocessing is essential for building accurate chemometric models. Raw spectra often contain unwanted variation from physical effects (scatter, baseline drift) that obscure the chemical information we're trying to model. This vignette covers each preprocessing technique available in measure and when to use them.

## Why preprocess spectra?

Before diving into specific techniques, let's understand what we're dealing with. Here are raw NIR spectra from the meats dataset:

```{r raw-spectra}
rec_raw <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths)

raw_data <- get_internal(rec_raw)

plot_spectra(raw_data, "Raw NIR Spectra", "Note the vertical offset differences between samples")
```

Notice how spectra are shifted vertically relative to each other? This offset isn't due to chemical differences - it's caused by physical factors like particle size, path length, and light scatter. Our preprocessing goal is to remove these unwanted effects while preserving the chemical information.

## Savitzky-Golay Filtering

### What it does

The Savitzky-Golay filter performs polynomial smoothing and can compute derivatives. It fits a polynomial to a sliding window of points, using the polynomial's value (or derivative) at the center point as the output.

### When to use it

- **Smoothing (order = 0)**: Reduce random noise while preserving peak shapes
- **First derivative (order = 1)**: Remove constant baseline offsets, enhance peak differences
- **Second derivative (order = 2)**: Remove linear baseline trends, further enhance peak resolution

### Parameters

- `window_side`: Number of points on each side of the center point (total window = 2 * window_side + 1)
- `differentiation_order`: 0 for smoothing, 1 for first derivative, 2 for second derivative
- `degree`: Polynomial degree (defaults to differentiation_order + 1)

### Examples

```{r sg-examples}
# Just smoothing
rec_smooth <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_savitzky_golay(window_side = 7, differentiation_order = 0)

# First derivative
rec_d1 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_savitzky_golay(window_side = 5, differentiation_order = 1)

# Second derivative
rec_d2 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_savitzky_golay(window_side = 7, differentiation_order = 2)
```

```{r sg-plots, fig.height = 8}
library(patchwork)

p1 <- plot_spectra(raw_data, "Raw")
p2 <- plot_spectra(get_internal(rec_smooth), "Smoothed (window = 15)")
p3 <- plot_spectra(get_internal(rec_d1), "1st Derivative", "Baseline offset removed")
p4 <- plot_spectra(get_internal(rec_d2), "2nd Derivative", "Linear baseline removed")

(p1 + p2) / (p3 + p4)
```

### Choosing window size

The window size is a bias-variance trade-off:
- **Smaller window**: Less smoothing, preserves sharp features, more noise
- **Larger window**: More smoothing, may blur sharp peaks, less noise

A good starting point is a window that spans the narrowest feature you want to preserve.

```{r window-comparison}
windows <- c(3, 7, 15)

window_data <- lapply(windows, function(w) {
  rec <- recipe(water ~ ., data = meats) |>
    step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
    step_measure_savitzky_golay(window_side = w, differentiation_order = 1)

  get_internal(rec) |>
    filter(sample_id == 1) |>
    mutate(window = paste0("window_side = ", w))
}) |>
  bind_rows()

ggplot(window_data, aes(x = location, y = value, color = window)) +
  geom_line() +
  labs(
    x = "Wavelength",
    y = "Signal",
    title = "Effect of Window Size on First Derivative",
    color = NULL
  ) +
  theme_minimal()
```

### Tuning with dials

The Savitzky-Golay step is tunable! This means you can use `tune()` to find optimal parameters:

```{r tunable, eval = FALSE}
library(tune)
library(workflows)

rec_tunable <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_savitzky_golay(
    window_side = tune(),
    differentiation_order = tune()
  ) |>
  step_measure_output_wide()

# The tunable parameters are:
tunable(rec_tunable)
```

## Standard Normal Variate (SNV)

### What it does

SNV normalizes each spectrum independently by centering and scaling:

$$SNV(x) = \frac{x - \bar{x}}{s_x}$$

where $\bar{x}$ is the spectrum's mean and $s_x$ is its standard deviation.

### When to use it

- Remove multiplicative scatter effects
- Correct for path length variations
- Normalize spectra to similar magnitude

SNV is particularly effective for diffuse reflectance spectra where particle size causes scatter variations.

### Example

```{r snv-example}
rec_snv <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_snv()

snv_data <- get_internal(rec_snv)
plot_spectra(snv_data, "After SNV Normalization", "Each spectrum has mean = 0 and sd = 1")
```

### Combining with derivatives

SNV is often combined with Savitzky-Golay derivatives. The order matters:

```{r snv-combination}
# Derivative then SNV (more common)
rec_d1_snv <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_savitzky_golay(window_side = 5, differentiation_order = 1) |>
  step_measure_snv()

plot_spectra(get_internal(rec_d1_snv), "1st Derivative + SNV",
             "Combined baseline removal and scatter correction")
```

## Multiplicative Scatter Correction (MSC)

### What it does

MSC aligns each spectrum to a reference spectrum (typically the mean of all training spectra) by correcting for additive and multiplicative effects:

1. Fit each spectrum $x_i$ to the reference $x_r$: $x_i = m_i \cdot x_r + a_i$
2. Correct: $MSC(x_i) = \frac{x_i - a_i}{m_i}$

### When to use it

- Similar applications to SNV
- When you have a good reference spectrum
- Often slightly better than SNV for scatter correction

### How it differs from SNV

- **SNV**: Each spectrum normalized independently (no reference needed)
- **MSC**: All spectra aligned to a common reference (learns reference during prep)

This means MSC is a *trained* step - it learns the reference spectrum from training data and applies the same reference to new data.

### Example

```{r msc-example}
rec_msc <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_msc()

msc_data <- get_internal(rec_msc)
plot_spectra(msc_data, "After MSC", "Spectra aligned to mean reference")
```

### Comparing SNV and MSC

```{r snv-vs-msc, fig.height = 6}
p_snv <- plot_spectra(get_internal(rec_snv), "SNV")
p_msc <- plot_spectra(get_internal(rec_msc), "MSC")

p_snv / p_msc
```

Both methods produce similar results for this dataset. In practice, try both and compare model performance.

## Sample-wise Normalization

The measure package provides several sample-wise normalization methods that normalize each spectrum independently. Unlike SNV/MSC which address scatter, these methods adjust for differences in total signal intensity.

### Available methods

| Step | Formula | Use case |
|------|---------|----------|
| `step_measure_normalize_sum()` | $x / \sum x$ | Total intensity normalization |
| `step_measure_normalize_max()` | $x / \max(x)$ | Peak-focused analysis |
| `step_measure_normalize_range()` | $(x - \min) / (\max - \min)$ | Scale to 0-1 range |
| `step_measure_normalize_vector()` | $x / \|x\|_2$ | L2/Euclidean normalization |
| `step_measure_normalize_auc()` | $x / AUC$ | Chromatography (area under curve) |
| `step_measure_normalize_peak()` | $x / f(\text{region})$ | Internal standard normalization |

### Sum normalization

Divides each spectrum by its total intensity. After transformation, all spectra sum to 1:

```{r normalize-sum}
rec_norm_sum <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_normalize_sum()

plot_spectra(get_internal(rec_norm_sum), "Sum Normalized",
             "Each spectrum sums to 1")
```

### Max normalization

Divides each spectrum by its maximum value, useful for peak-focused analysis:

```{r normalize-max}
rec_norm_max <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_normalize_max()

plot_spectra(get_internal(rec_norm_max), "Max Normalized",
             "Each spectrum has maximum = 1")
```

### Peak region normalization (tunable)

When you have an internal standard at a known location, use `step_measure_normalize_peak()` to normalize by a specific region:

```{r normalize-peak}
rec_norm_peak <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_normalize_peak(
    location_min = 900,
    location_max = 950,
    method = "mean"  # or "max" or "integral"
  )

plot_spectra(get_internal(rec_norm_peak), "Peak Region Normalized",
             "Normalized by mean of region 900-950")
```

The `location_min` and `location_max` parameters are tunable:

```{r peak-tunable, eval = FALSE}
rec_tunable_peak <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_normalize_peak(
    location_min = tune(),
    location_max = tune(),
    method = "mean"
  ) |>
  step_measure_output_wide()
```

## Variable-wise Scaling

While sample-wise methods normalize each spectrum independently, variable-wise scaling operates across samples at each measurement location. These methods **learn statistics from training data** and apply them consistently to new data.

### When to use variable-wise scaling

- **Before PCA/PLS**: Centering is essential; scaling equalizes variable importance
- **When variables have different scales**: Auto-scaling gives equal weight to all locations
- **For metabolomics data**: Pareto scaling is common practice

### Mean centering

`step_measure_center()` subtracts the column mean at each location:

```{r center}
rec_center <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_center()

center_data <- get_internal(rec_center)
plot_spectra(center_data, "Mean Centered",
             "Column means are zero")
```

### Auto-scaling (z-score)

`step_measure_scale_auto()` centers and scales to unit variance at each location:

```{r scale-auto}
rec_auto <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_scale_auto()

auto_data <- get_internal(rec_auto)
plot_spectra(auto_data, "Auto-Scaled (Z-Score)",
             "Column means = 0, SDs = 1")
```

### Pareto scaling

`step_measure_scale_pareto()` divides by the square root of the standard deviation - a compromise between no scaling and auto-scaling:

```{r scale-pareto}
rec_pareto <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
  step_measure_scale_pareto()

pareto_data <- get_internal(rec_pareto)
plot_spectra(pareto_data, "Pareto Scaled",
             "Reduces influence of large values while preserving fold changes")
```

### Comparing scaling methods

```{r scale-comparison, fig.height = 8}
p_raw <- plot_spectra(raw_data, "Raw")
p_center <- plot_spectra(center_data, "Centered")
p_auto <- plot_spectra(auto_data, "Auto-Scaled")
p_pareto <- plot_spectra(pareto_data, "Pareto Scaled")

(p_raw + p_center) / (p_auto + p_pareto)
```

### Learned parameters

Variable-wise scaling steps store learned parameters that can be examined after training:

```{r tidy-scaling}
rec_prepped <- prep(rec_auto)

# View learned parameters
tidy_params <- tidy(rec_prepped, number = 2)
head(tidy_params)

# Plot the learned means and SDs
ggplot(tidy_params, aes(x = location)) +
  geom_line(aes(y = mean), color = "blue") +
  geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd), alpha = 0.3, fill = "blue") +
  labs(x = "Wavelength", y = "Value",
       title = "Learned Parameters from Auto-Scaling",
       subtitle = "Mean ± 1 SD at each wavelength") +
  theme_minimal()
```

## Custom Transformations

### When built-in steps aren't enough

The built-in preprocessing steps cover the most common operations, but you may need domain-specific transformations:

- Custom baseline correction algorithms
- Instrument-specific corrections
- Experimental preprocessing techniques
- Transformations from specialized packages

`step_measure_map()` provides an "escape hatch" for applying any custom function to your measurements while staying within the recipes framework.

### Using step_measure_map()

The function you provide must accept a tibble with `location` and `value` columns and return a tibble with the same structure:
```{r custom-step}
# Example: Shift spectra to start at zero
zero_baseline <- function(x) {

x$value <- x$value - min(x$value)
x
}

rec_custom <- recipe(water ~ ., data = meats) |>
step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
step_measure_map(zero_baseline) |>
step_measure_snv()

plot_spectra(get_internal(rec_custom), "Custom Zero-Baseline + SNV")
```

### Formula syntax for inline transformations

For simple transformations, use formula syntax instead of defining a separate function:

```{r custom-formula}
rec_inline <- recipe(water ~ ., data = meats) |>
step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
step_measure_map(~ {
# Log transform (common for absorbance data)
.x$value <- log1p(.x$value)
.x
})
```

### Passing additional arguments

You can pass extra arguments to your transformation function:

```{r custom-args, eval = FALSE}
# A function with configurable parameters
robust_scale <- function(x, center_fn = median, scale_fn = mad) {
x$value <- (x$value - center_fn(x$value)) / scale_fn(x$value)
x
}

# Use with custom parameters
rec <- recipe(water ~ ., data = meats) |>
step_measure_input_wide(starts_with("x_")) |>
step_measure_map(robust_scale, center_fn = mean, scale_fn = sd)
```

### Prototyping with measure_map()
When developing a custom transformation, it helps to prototype interactively before putting it in a recipe. Use `measure_map()` for exploration:

```{r prototype-workflow}
# First, get data in internal format
rec_internal <- recipe(water ~ ., data = meats) |>
step_measure_input_wide(starts_with("x_"), location_values = wavelengths) |>
prep()

baked_data <- bake(rec_internal, new_data = NULL)

# Prototype your transformation
result <- measure_map(baked_data, ~ {
# Experiment with different approaches
.x$value <- .x$value - median(.x$value)
.x
})

# Check results
result$.measures[[1]]
```

Once your transformation works correctly, move it into `step_measure_map()` for production use. This ensures the transformation is:

- Applied consistently during `prep()` and `bake()`
- Included when bundling recipes into workflows
- Reproducible across sessions

### Handling problematic samples

Use `measure_map_safely()` when exploring data that might have problematic samples:

```{r safely-example, eval = FALSE}
# A transformation that might fail for some samples
risky_transform <- function(x) {
if (any(x$value <= 0)) stop("Non-positive values!")
x$value <- log(x$value)
x
}

# Errors are captured, not thrown
result <- measure_map_safely(baked_data, risky_transform)

# Check which samples failed
if (nrow(result$errors) > 0) {
print(result$errors)
}

# result$result contains the data with successful transforms
# (failed samples keep their original values)
```

### Understanding your data with measure_summarize()

Before preprocessing, it's often helpful to compute summary statistics across samples:

```{r summarize-example}
# Compute mean and SD at each wavelength
summary_stats <- measure_summarize(baked_data)
summary_stats

# Visualize the mean spectrum with variability
ggplot(summary_stats, aes(x = location)) +
geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd), alpha = 0.3) +
geom_line(aes(y = mean)) +
labs(x = "Wavelength", y = "Signal", title = "Mean Spectrum ± 1 SD") +
theme_minimal()
```

This can help identify:
- Wavelength regions with high variability
- Potential outliers
- Reference spectra for custom corrections

## Preprocessing pipelines

### Common combinations

Here are some commonly used preprocessing pipelines:

```{r pipelines}
# Pipeline 1: Basic scatter correction
pipe1 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_snv() |>
  step_measure_output_wide()

# Pipeline 2: Derivative + normalization
pipe2 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_savitzky_golay(window_side = 5, differentiation_order = 1) |>
  step_measure_snv() |>
  step_measure_output_wide()

# Pipeline 3: Second derivative (often enough on its own)
pipe3 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_savitzky_golay(window_side = 7, differentiation_order = 2) |>
  step_measure_output_wide()

# Pipeline 4: MSC + smoothing
pipe4 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_msc() |>
  step_measure_savitzky_golay(window_side = 5, differentiation_order = 0) |>
  step_measure_output_wide()

# Pipeline 5: For PCA/PLS - SNV + centering
pipe5 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_snv() |>
  step_measure_center() |>
  step_measure_output_wide()

# Pipeline 6: Metabolomics-style with Pareto scaling
pipe6 <- recipe(water ~ ., data = meats) |>
  step_measure_input_wide(starts_with("x_")) |>
  step_measure_normalize_sum() |>
  step_measure_scale_pareto() |>
  step_measure_output_wide()
```

### Order of operations

The order of preprocessing steps matters. General guidelines:

1. **Derivatives first**: Apply Savitzky-Golay derivatives before other transformations
2. **Sample-wise normalization before variable-wise scaling**: Normalize spectra (SNV, MSC, normalize_*) before centering/scaling
3. **Center/scale last**: Variable-wise scaling should typically be the final step before modeling
4. **Keep it simple**: Often, a single well-chosen step outperforms complex pipelines

A typical order might be:
```
Derivatives → Sample normalization (SNV/MSC) → Variable scaling (center/auto-scale)
```

## Summary table

### Filtering and Scatter Correction

| Step | Effect | Use when |
|------|--------|----------|
| `step_measure_savitzky_golay(order=0)` | Smoothing | High-frequency noise |
| `step_measure_savitzky_golay(order=1)` | 1st derivative | Baseline offsets |
| `step_measure_savitzky_golay(order=2)` | 2nd derivative | Linear baselines |
| `step_measure_snv()` | Row normalization | Scatter, path length |
| `step_measure_msc()` | Align to reference | Scatter (supervised) |

### Sample-wise Normalization

| Step | Effect | Use when |
|------|--------|----------|
| `step_measure_normalize_sum()` | Divide by sum | Total intensity differences |
| `step_measure_normalize_max()` | Divide by max | Peak-focused analysis |
| `step_measure_normalize_range()` | Scale to 0-1 | Neural networks, visualization |
| `step_measure_normalize_vector()` | L2 normalization | Euclidean distance methods |
| `step_measure_normalize_auc()` | Divide by AUC | Chromatography |
| `step_measure_normalize_peak()` | Divide by region | Internal standard |

### Variable-wise Scaling

| Step | Effect | Use when |
|------|--------|----------|
| `step_measure_center()` | Subtract mean | Before PCA/PLS (essential) |
| `step_measure_scale_auto()` | Z-score | Equal variable importance |
| `step_measure_scale_pareto()` | Pareto scaling | Metabolomics |
| `step_measure_scale_range()` | Range scaling | Bounded scaling |
| `step_measure_scale_vast()` | VAST scaling | Variable stability focus |

### Custom

| Step | Effect | Use when |
|------|--------|----------|
| `step_measure_map(fn)` | Custom transformation | Domain-specific needs |

## Tips for choosing preprocessing

1. **Start simple**: Try SNV or first derivative alone before complex pipelines
2. **Visualize**: Always plot preprocessed spectra to check for artifacts
3. **Validate**: Use cross-validation to compare preprocessing strategies
4. **Domain knowledge**: Consider the physics of your measurement system
5. **Tune**: Use `tune()` to optimize Savitzky-Golay parameters

## References

- Savitzky, A., and Golay, M. J. E. (1964). Smoothing and Differentiation of Data by Simplified Least Squares Procedures. *Analytical Chemistry*, 36(8), 1627-1639.
- Barnes, R. J., Dhanoa, M. S., and Lister, S. J. (1989). Standard Normal Variate Transformation and De-Trending of Near-Infrared Diffuse Reflectance Spectra. *Applied Spectroscopy*, 43(5), 772-777.
- Geladi, P., MacDougall, D., and Martens, H. (1985). Linearization and Scatter-Correction for Near-Infrared Reflectance Spectra of Meat. *Applied Spectroscopy*, 39(3), 491-500.
